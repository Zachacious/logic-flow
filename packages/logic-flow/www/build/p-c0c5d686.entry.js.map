{"version":3,"names":["logicFlowConnectorCss","LogicFlowConnectorStyle0","LogicFlowConnector","render","sideClass","this","type","typeClass","h","Host","key","class","connections","length","logicFlowNodeCss","LogicFlowNodeStyle0","LogicFlowNode","style","x","y","componentWillLoad","updateTransform","onPositionChange","position","newValue","JSON","parse","el","transform","componentWillRender","isVisible","display","tabIndex","debounce","fn","delay","timeout","args","clearTimeout","setTimeout","throttle","lastFunc","lastRan","Date","now","getEventLocation","e","MouseEvent","clientX","clientY","TouchEvent","touches","changedTouches","urlAlphabet","nanoid","size","id","bytes","crypto","getRandomValues","Uint8Array","scopedUrlAlphabet","Quadtree","constructor","boundary","capacity","camera","objects","divided","northeast","northwest","southeast","southwest","subdivide","left","top","width","height","halfWidth","halfHeight","insert","object","push","remove","removeFromNode","node","originalLength","filter","obj","contains","containsPoint","containsRect","point","rect","query","range","found","pan","zoom","intersects","forEach","inRange","pointInRange","rectInRange","adjX","adjY","adjLeft","adjTop","adjRight","adjBottom","checkNearby","coords","bounds","nearby","pos","Camera","uid","toScreenCoords","worldCoords","toWorldCoords","screenCoords","ViewContext","viewport","nodes","Map","connectors","connectorSnapDistance","connectorRects","connectionRects","nodeRects","visibleElements","prevVisibleElements","needsRedraw","initialPinchDistance","isPanning","snapToGrid","dragStart","activeNodeDragging","activeNodeDragStart","activeConnectorStartPos","viewportOffset","bringingToFront","debouncedUpdateVisibleElements","updateVisibleElements","viewportId","instances","has","get","set","viewportRect","getBoundingClientRect","boundry","connectorQuadtree","viewportQuadtree","initializeViewport","observer","MutationObserver","m","viewportMutation","observe","childList","subtree","destroy","disconnect","delete","updateViewportRect","viewportEl","addNode","setAttribute","updateViewportQuadtree","requestAnimationFrame","updateNodeConnectorsQuadtree","removeNode","console","log","querySelectorAll","connector","cid","connection","removeConnection","removeConnector","addConnector","connectorEl","querySelector","addConnection","connIndex","indexOf","splice","connectingConnector","mutations","mutation","i","addedNodes","HTMLElement","tagName","logicNode","logicConnector","logicConnection","removedNodes","getAttribute","instance","contentEl","children","traverse","bringToFront","_a","parentElement","appendChild","setCursor","cursor","document","body","resetCursor","getRectCenter","startPanning","panCamera","loc","resetPointerStates","startNodeDrag","target","closest","activeNode","updateNodeConnectorPos","aNode","delta","Object","assign","updateNodeConnectorConnectionsPos","end","start","calcSnapToGrid","gridSize","Math","round","calcNodePos","moveNode","oldPos","newPos","clientWidth","clientHeight","endNodeDrag","path","createNewConnection","startPos","createElement","activeConnection","moveActiveConnection","snappingDist","aConn","snappableConnector","getTargetConnector","targetConnector","snappedConnector","startNewConnection","connEl","activeConnector","parentConn","center","processConnection","tConn","tNode","isValidConnection","updateConnectionEndpoints","finalizeConnection","targetConn","active","targRect","clear","add","startDisconnectConnection","snapConnector","disconnectConnector","swapConnectionEndpoints","c","r","entity","visibleEntities","newVisibleElements","map","allItems","Set","getElementById","entityComponent","curstate","prevState","includes","newstate","renderCanvasGrid","canvas","color","bgColor","ctx","getContext","step","strokeStyle","lineWidth","fillStyle","fillRect","offsetX","offsetY","beginPath","moveTo","lineTo","stroke","renderCanvasDotGrid","logicFlowViewportCss","LogicFlowViewportStyle0","LogicFlowViewport","debouncedResize","onResize","debouncedUpdateScreen","updateScreen","debouncedUpdateViewportRect","throttledTouchMove","handleTouchMove","forceContentReflowDebounced","forceContentReflow","elMouseDown","onPointerDown","elMouseUp","onPointerUp","elMouseMove","onPointerMove","elTouchStart","handleTouchStart","elTouchMove","elTouchEnd","elWheel","handleWheel","elScroll","elKeyPress","onKeyPress","default","panning","moving","componentDidLoad","gridEl","connectorSnappingDistance","window","addEventListener","passive","resizeObserver","ResizeObserver","renderGrid","disconnectedCallback","canvasEl","removeEventListener","getCamera","screenToWorldCoords","onSnapToGridChange","onGridTypeChange","scheduleComponentUpdate","showGrid","gridType","gridLineColor","gridBgColor","event","activeElement","elementFromPoint","cursors","onEndActiveConnection","preventDefault","canvasRect","mouseX","mouseY","zoomDelta","deltaY","zoomSpeed","newZoom","min","maxZoom","max","minZoom","scaleFactor","newPanX","newPanY","handlePinch","touch1","touch2","distance","sqrt","pinchCenterX","pinchCenterY","adjustZoomOnPinch","pinchContentX","pinchContentY","cdisplay"],"sources":["src/components/logic-flow-connector/logic-flow-connector.css?tag=logic-flow-connector","src/components/logic-flow-connector/logic-flow-connector.tsx","src/components/logic-flow-node/logic-flow-node.css?tag=logic-flow-node","src/components/logic-flow-node/logic-flow-node.tsx","src/utils/debounce.ts","src/utils/throttle.ts","src/utils/getEventLocation.ts","../../node_modules/nanoid/url-alphabet/index.js","../../node_modules/nanoid/index.browser.js","src/types/Quadtree.ts","src/types/Camera.ts","src/types/ViewContext.ts","src/utils/renderCanvasGrid.ts","src/components/logic-flow-viewport/logic-flow-viewport.css?tag=logic-flow-viewport","src/components/logic-flow-viewport/logic-flow-viewport.tsx"],"sourcesContent":[":host {\n  display: block;\n}\n","import { Component, Host, Prop, h, Element } from '@stencil/core';\nimport { LogicFlowConnection } from '../logic-flow-connection/logic-flow-connection';\n\n@Component({\n  tag: 'logic-flow-connector',\n  styleUrl: 'logic-flow-connector.css',\n  shadow: false,\n})\nexport class LogicFlowConnector {\n  @Element() el: HTMLElement;\n\n  @Prop() type: 'input' | 'output' = 'input';\n  @Prop() connectingConnector: LogicFlowConnector | null = null;\n  @Prop() connections: LogicFlowConnection[] = [];\n\n  render() {\n    const sideClass =\n      this.type === 'input' ? 'left-connector' : 'right-connector';\n    const typeClass =\n      this.type === 'input' ? 'input-connector' : 'output-connector';\n\n    return (\n      <Host class={`logic-flow-connector ${typeClass}`}>\n        <div\n          class={`connector ${sideClass} ${\n            (this.connections.length > 0 && 'connected') || ''\n          }`}\n        ></div>\n        <div class={`connector-content ${sideClass}`}>\n          <slot></slot>\n        </div>\n      </Host>\n    );\n  }\n}\n",":host {\n  display: block;\n}\n","import { Component, Host, Prop, h, Element, State, Watch } from '@stencil/core';\nimport { Coords } from '../../types/Coords';\n\n@Component({\n  tag: 'logic-flow-node',\n  styleUrl: 'logic-flow-node.css',\n  shadow: false,\n})\nexport class LogicFlowNode {\n  @Element() el: HTMLElement;\n\n  @Prop() type: string = 'default';\n  // @Prop() name: string = 'Node';\n  @Prop({ mutable: true }) position: Coords = { x: 0, y: 0 };\n  @Prop({ mutable: true }) isVisible: boolean = true;\n\n  @State() isDragging = false;\n\n  style = {};\n\n  componentWillLoad() {\n    //  set initial size\n    this.updateTransform();\n\n    // this.position = { x: this.position.x, y: this.position.y };\n    this.onPositionChange(this.position);\n  }\n\n  @Watch('position')\n  onPositionChange(newValue: Coords | string) {\n    if (typeof newValue === 'string') {\n      this.position = JSON.parse(newValue);\n    }\n    // update transform\n    this.updateTransform();\n  }\n\n  updateTransform() {\n    this.el.style.transform = `translate(${this.position.x}px, ${this.position.y}px )`;\n  }\n\n  componentWillRender() {\n    if (!this.isVisible) {\n      this.style = { display: 'none' };\n    } else {\n      this.style = {};\n    }\n  }\n\n  render() {\n    // console.log('render', this.isVisible);\n    return (\n      <Host class=\"logic-flow-node\" style={this.style} tabIndex=\"0\">\n        {/* <div class=\"logic-flow-node-header\">\n          {this.name}\n          <slot name=\"header\"></slot>\n        </div> */}\n        <slot></slot>\n        {/* <div class=\"logic-flow-node-footer\">\n          <slot name=\"footer\"></slot>\n        </div> */}\n      </Host>\n    );\n  }\n}\n","export const debounce = (fn: (...args: any[]) => void, delay: number) => {\n  let timeout: ReturnType<typeof setTimeout>;\n  return (...args: any[]) => {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => {\n      fn(...args);\n    }, delay);\n  };\n};\n","export const throttle = (fn: (...args: any[]) => void, delay: number) => {\n  let lastFunc: ReturnType<typeof setTimeout>;\n  let lastRan: number;\n  return (...args: any[]) => {\n    if (!lastRan) {\n      fn(...args);\n      lastRan = Date.now();\n    } else {\n      clearTimeout(lastFunc);\n      lastFunc = setTimeout(() => {\n        if (Date.now() - lastRan >= delay) {\n          fn(...args);\n          lastRan = Date.now();\n        }\n      }, delay - (Date.now() - lastRan));\n    }\n  };\n};\n","export const getEventLocation = (e: MouseEvent | TouchEvent) => {\n  if (e instanceof MouseEvent) {\n    return { x: e.clientX, y: e.clientY };\n  } else if (e instanceof TouchEvent && e.touches.length > 0) {\n    return { x: e.touches[0].clientX, y: e.touches[0].clientY };\n  } else if (e instanceof TouchEvent && e.changedTouches.length > 0) {\n    return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };\n  }\n  return { x: 0, y: 0 };\n};\n","export const urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\n","import { urlAlphabet as scopedUrlAlphabet } from './url-alphabet/index.js'\nexport { urlAlphabet } from './url-alphabet/index.js'\nexport let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\nexport let customRandom = (alphabet, defaultSize, getRandom) => {\n  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1\n  let step = -~((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let j = step\n      while (j--) {\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length === size) return id\n      }\n    }\n  }\n}\nexport let customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size, random)\nexport let nanoid = (size = 21) => {\n  let id = ''\n  let bytes = crypto.getRandomValues(new Uint8Array(size))\n  while (size--) {\n    id += scopedUrlAlphabet[bytes[size] & 63]\n  }\n  return id\n}\n","import { Coords } from './Coords';\nimport { Rect } from './Rect';\nimport { Camera } from './Camera';\n\n// SpatialObject can be either a Point or a Rect with an ID for tracking\ntype SpatialObject = Point | BBox;\n\ninterface Point extends Coords {\n  id: string; // Unique ID of the point (e.g., connector)\n}\n\ninterface BBox extends Rect {\n  id: string; // Unique ID of the rect (e.g., node)\n}\n\nexport class Quadtree {\n  boundary: Rect;\n  capacity: number;\n  objects: SpatialObject[];\n  divided: boolean;\n  northeast: Quadtree | null;\n  northwest: Quadtree | null;\n  southeast: Quadtree | null;\n  southwest: Quadtree | null;\n  camera: Camera;\n\n  constructor(boundary: Rect, capacity: number, camera: Camera) {\n    this.boundary = boundary;\n    this.capacity = capacity;\n    this.objects = [];\n    this.divided = false;\n    this.northeast = null;\n    this.northwest = null;\n    this.southeast = null;\n    this.southwest = null;\n    this.camera = camera;\n  }\n\n  subdivide() {\n    const { left, top, width, height } = this.boundary;\n    const halfWidth = width / 2;\n    const halfHeight = height / 2;\n\n    this.northeast = new Quadtree(\n      { left: left + halfWidth, top, width: halfWidth, height: halfHeight },\n      this.capacity,\n      this.camera,\n    );\n    this.northwest = new Quadtree(\n      { left, top, width: halfWidth, height: halfHeight },\n      this.capacity,\n      this.camera,\n    );\n    this.southeast = new Quadtree(\n      {\n        left: left + halfWidth,\n        top: top + halfHeight,\n        width: halfWidth,\n        height: halfHeight,\n      },\n      this.capacity,\n      this.camera,\n    );\n    this.southwest = new Quadtree(\n      { left, top: top + halfHeight, width: halfWidth, height: halfHeight },\n      this.capacity,\n      this.camera,\n    );\n\n    this.divided = true;\n  }\n\n  insert(object: SpatialObject): boolean {\n    // if (!this.contains(object)) console.log('Object out of bounds');\n    // if (!this.contains(object)) return false;\n\n    if (this.objects.length < this.capacity) {\n      this.objects.push(object);\n      return true;\n    } else {\n      if (!this.divided) this.subdivide();\n\n      return (\n        this.northeast!.insert(object) ||\n        this.northwest!.insert(object) ||\n        this.southeast!.insert(object) ||\n        this.southwest!.insert(object)\n      );\n    }\n  }\n\n  remove(id: string): boolean {\n    const removeFromNode = (node: Quadtree | null): boolean => {\n      if (!node) return false;\n\n      const originalLength = node.objects.length;\n      node.objects = node.objects.filter(obj => (obj as any).id !== id);\n\n      // If any objects were removed, return true\n      if (originalLength !== node.objects.length) return true;\n\n      // Recursively remove from child nodes if subdivided\n      if (node.divided) {\n        return (\n          removeFromNode(node.northwest) ||\n          removeFromNode(node.northeast) ||\n          removeFromNode(node.southwest) ||\n          removeFromNode(node.southeast)\n        );\n      }\n      return false;\n    };\n\n    return removeFromNode(this);\n  }\n\n  contains(object: SpatialObject): boolean {\n    if ('x' in object && 'y' in object) {\n      // It's a point\n      return this.containsPoint(object);\n    } else {\n      // It's a rect\n      return this.containsRect(object);\n    }\n  }\n\n  containsPoint(point: Point): boolean {\n    const { left, top, width, height } = this.boundary;\n    return (\n      point.x >= left &&\n      point.x < left + width &&\n      point.y >= top &&\n      point.y < top + height\n    );\n  }\n\n  containsRect(rect: Rect): boolean {\n    const { left, top, width, height } = this.boundary;\n    return (\n      rect.left >= left &&\n      rect.left + rect.width <= left + width &&\n      rect.top >= top &&\n      rect.top + rect.height <= top + height\n    );\n  }\n\n  query(\n    range: Rect,\n    found: SpatialObject[] = [],\n    pan: Coords,\n    zoom: number,\n  ): SpatialObject[] {\n    if (!this.intersects(range)) return found;\n\n    this.objects.forEach(obj => {\n      if (this.inRange(obj, range, pan, zoom)) {\n        found.push(obj);\n      }\n    });\n\n    if (this.divided) {\n      this.northwest!.query(range, found, pan, zoom);\n      this.northeast!.query(range, found, pan, zoom);\n      this.southwest!.query(range, found, pan, zoom);\n      this.southeast!.query(range, found, pan, zoom);\n    }\n\n    return found;\n  }\n\n  inRange(\n    object: SpatialObject,\n    range: Rect,\n    pan: Coords,\n    zoom: number,\n  ): boolean {\n    if ('x' in object && 'y' in object) {\n      // It's a point\n      return this.pointInRange(object, range, pan, zoom);\n    } else {\n      // It's a rect\n      return this.rectInRange(object, range, pan, zoom);\n    }\n  }\n\n  pointInRange(point: Point, range: Rect, pan: Coords, zoom: number): boolean {\n    // Adjust point position relative to pan and zoom\n    const adjX = (point.x + pan.x) * zoom;\n    const adjY = (point.y + pan.y) * zoom;\n\n    // const screenX = adjX / zoom - pan.x;\n    // const screenY = adjY / zoom - pan.y;\n\n    // // show debug\n    // const debugDiv = document.getElementById('debug');\n    // debugDiv.style.left = `${screenX}px`;\n    // debugDiv.style.top = `${screenY}px`;\n    // debugDiv.style.width = '10px';\n    // debugDiv.style.height = '10px';\n\n    // // show debug range\n    // const screenRange = {\n    //   left: range.left / zoom - pan.x,\n    //   top: range.top / zoom - pan.y,\n    //   width: range.width / zoom,\n    //   height: range.height / zoom,\n    // };\n\n    // const debugDiv2 = document.getElementById('debug2');\n    // debugDiv2.style.left = `${screenRange.left}px`;\n    // debugDiv2.style.top = `${screenRange.top}px`;\n    // debugDiv2.style.width = `${screenRange.width}px`;\n    // debugDiv2.style.height = `${screenRange.height}px`;\n\n    return (\n      adjX >= range.left &&\n      adjX < range.left + range.width &&\n      adjY >= range.top &&\n      adjY < range.top + range.height\n    );\n  }\n\n  rectInRange(rect: Rect, range: Rect, pan: Coords, zoom: number): boolean {\n    // Adjust rect position relative to pan and zoom\n    const adjLeft = (rect.left + pan.x) * zoom;\n    const adjTop = (rect.top + pan.y) * zoom;\n\n    const adjRight = adjLeft + rect.width * zoom;\n    const adjBottom = adjTop + rect.height * zoom;\n\n    // const screenW = (adjRight - adjLeft) / this.camera.zoom;\n    // const screenH = (adjBottom - adjTop) / this.camera.zoom;\n    // const screenX = adjLeft / this.camera.zoom - pan.x;\n    // const screenY = adjTop / this.camera.zoom - pan.y;\n\n    // const debugDiv2 = document.getElementById('debug2');\n    // debugDiv2.style.width = `${screenW}px`;\n    // debugDiv2.style.height = `${screenH}px`;\n    // debugDiv2.style.left = `${screenX}px`;\n    // debugDiv2.style.top = `${screenY}px`;\n\n    // const screenRange = {\n    //   left: range.left / zoom - pan.x,\n    //   top: range.top / zoom - pan.y,\n    //   width: range.width / zoom,\n    //   height: range.height / zoom,\n    // };\n\n    // const debugDiv = document.getElementById('debug');\n    // debugDiv.style.width = `${screenRange.width}px`;\n    // debugDiv.style.height = `${screenRange.height}px`;\n    // debugDiv.style.left = `${screenRange.left}px`;\n    // debugDiv.style.top = `${screenRange.top}px`;\n\n    return !(\n      adjRight < range.left ||\n      adjLeft > range.left + range.width ||\n      adjBottom < range.top ||\n      adjTop > range.top + range.height\n    );\n  }\n\n  intersects(range: Rect): boolean {\n    const { left, top, width, height } = this.boundary;\n    return !(\n      range.left > left + width ||\n      range.left + range.width < left ||\n      range.top > top + height ||\n      range.top + range.height < top\n    );\n  }\n\n  checkNearby(coords: Coords, range: number): SpatialObject | null {\n    const bounds = {\n      left: coords.x - range / 2,\n      top: coords.y - range / 2,\n      width: range,\n      height: range,\n    };\n\n    const nearby = this.query(bounds, [], this.camera.pos, this.camera.zoom);\n\n    return nearby.length > 0 ? nearby[0] : null;\n  }\n}\n","import { nanoid } from 'nanoid';\nimport { Coords } from './Coords';\n\nexport class Camera {\n  uid: string;\n  pos: Coords;\n  zoom: number;\n\n  constructor() {\n    this.uid = nanoid();\n    this.pos = { x: 0, y: 0 };\n    this.zoom = 1;\n  }\n\n  toScreenCoords(worldCoords: Coords): Coords {\n    return {\n      x: (worldCoords.x - this.pos.x) * this.zoom,\n      y: (worldCoords.y - this.pos.y) * this.zoom,\n    };\n  }\n\n  toWorldCoords(screenCoords: Coords): Coords {\n    return {\n      x: screenCoords.x / this.zoom - this.pos.x,\n      y: screenCoords.y / this.zoom - this.pos.y,\n    };\n  }\n}\n","import { nanoid } from 'nanoid';\nimport { Rect } from './Rect';\nimport { Quadtree } from './Quadtree';\nimport { Camera } from './Camera';\nimport { Coords } from './Coords';\nimport { throttle } from '../utils/throttle';\nimport { Offset } from './Offset';\n// import { LogicFlowNode } from '../components/logic-flow-node/logic-flow-node';\n// import { LogicFlowConnection } from '../components/logic-flow-connection/logic-flow-connection';\n\n// type EntityType = 'node' | 'connector' | 'connection' | 'viewport';\n\nexport class ViewContext {\n  static instances = new Map<string, ViewContext>();\n\n  uid: string;\n  nodes = new Map<string, HTMLLogicFlowNodeElement>();\n  connectors = new Map<string, HTMLLogicFlowConnectorElement>();\n  connectorSnapDistance = 10;\n  connections = new Map<string, HTMLLogicFlowConnectionElement>();\n  connectorRects = <Record<string, Rect>>{};\n  connectionRects = <Record<string, Rect>>{};\n  connectorQuadtree: Quadtree;\n  viewportQuadtree: Quadtree;\n  nodeRects = <Record<string, Rect>>{};\n  camera = new Camera();\n  observer: MutationObserver;\n  visibleElements: string[] = [];\n  prevVisibleElements: string[] = [];\n\n  // viewport variables\n  viewportEl: HTMLDivElement;\n  contentEl: HTMLDivElement;\n  gridEl: HTMLCanvasElement;\n  needsRedraw = true;\n  viewportRect: Rect;\n  initialPinchDistance = 0;\n  isPanning = false;\n  snapToGrid = false;\n  dragStart: Coords = { x: 0, y: 0 };\n  activeNode: HTMLLogicFlowNodeElement;\n  activeNodeDragging = false;\n  activeNodeDragStart: Coords = { x: 0, y: 0 };\n  activeConnector: HTMLLogicFlowConnectorElement;\n  activeConnectorStartPos: Coords = { x: 0, y: 0 };\n  activeConnection: HTMLLogicFlowConnectionElement;\n  viewportOffset: Offset = { top: 0, left: 0 };\n  bringingToFront = false;\n\n  debouncedUpdateVisibleElements = throttle(\n    () => this.updateVisibleElements(),\n    100,\n  );\n\n  constructor(viewport: HTMLLogicFlowViewportElement) {\n    const id = viewport.id || nanoid();\n    viewport.id = id;\n    const viewportId = id;\n    if (ViewContext.instances.has(viewportId)) {\n      return ViewContext.instances.get(viewportId);\n    }\n    this.uid = viewportId;\n    ViewContext.instances.set(this.uid, this);\n\n    if (!this.viewportRect) {\n      const rect = viewport.getBoundingClientRect();\n      this.viewportOffset = {\n        top: rect.top,\n        left: rect.left,\n      };\n      this.viewportRect = {\n        left: rect.left - rect.left,\n        top: rect.top - rect.top,\n        width: rect.width - rect.left,\n        height: rect.height - rect.top,\n      };\n      // this.updateViewportRect();\n    }\n\n    const boundry = {\n      left: this.viewportRect.left,\n      top: this.viewportRect.top,\n      width: this.viewportRect.width,\n      height: this.viewportRect.height,\n    };\n\n    this.connectorQuadtree = new Quadtree(boundry, 4, this.camera);\n    this.viewportQuadtree = new Quadtree(boundry, 4, this.camera);\n\n    ViewContext.initializeViewport(viewport);\n\n    this.observer = new MutationObserver((m: MutationRecord[]) =>\n      this.viewportMutation(m),\n    );\n    this.observer.observe(viewport, {\n      childList: true,\n      subtree: true,\n    });\n  }\n\n  destroy() {\n    this.observer.disconnect();\n\n    ViewContext.instances.delete(this.uid);\n  }\n\n  updateViewportRect() {\n    const rect = this.viewportEl.getBoundingClientRect();\n    this.viewportOffset = {\n      top: rect.top,\n      left: rect.left,\n    };\n    this.viewportRect = {\n      left: rect.left - rect.left,\n      top: rect.top - rect.top,\n      width: rect.width - rect.left,\n      height: rect.height - rect.top,\n    };\n  }\n\n  // static seekAndDestroy(type: EntityType, id: string) {\n  //   // search and destroy in all instances\n  //   for (const [, instance] of ViewContext.instances) {\n  //     switch (type) {\n  //       case 'node':\n  //         instance.unregisterNode(id);\n  //         break;\n  //       case 'connector':\n  //         instance.unregisterConnector(id);\n  //         break;\n  //       case 'connection':\n  //         instance.unregisterConnection(id);\n  //         break;\n  //       case 'viewport':\n  //         instance.destroy();\n  //         break;\n  //     }\n  //   }\n  // }\n\n  addNode(node: HTMLLogicFlowNodeElement) {\n    const id = nanoid();\n    node.id = id;\n    this.nodes.set(id, node);\n\n    // set data attribute for the context id\n    node.setAttribute('data-viewport', this.uid);\n\n    // update rect\n    const rect = node.getBoundingClientRect();\n    this.nodeRects[id] = {\n      left: node.position.x,\n      top: node.position.y,\n      width: rect.width,\n      height: rect.height,\n    };\n\n    // add to quadtree\n    this.updateViewportQuadtree(node);\n    // wait for next frame to update connectors rects until the connectors have registered\n    requestAnimationFrame(() => {\n      this.updateNodeConnectorsQuadtree(node);\n    });\n\n    return id;\n  }\n\n  removeNode(id: string) {\n    console.log('remove node', id);\n    // remove all connections and connectors associated with the node\n    // get connectors\n    const node = this.nodes.get(id);\n    if (node) {\n      // TODO: not sure if this is necessary with mutation observer\n\n      const connectors = node.querySelectorAll('logic-flow-connector');\n      connectors.forEach((connector: HTMLLogicFlowConnectorElement) => {\n        const cid = connector.id;\n        // remove connections\n        connector.connections.forEach(\n          (connection: HTMLLogicFlowConnectionElement) => {\n            const id = connection.id;\n            if (id) this.removeConnection(id);\n          },\n        );\n        // remove connector\n        this.removeConnector(cid);\n      });\n\n      // remove from quadtree\n      this.viewportQuadtree.remove(id);\n      delete this.nodeRects[id];\n      // node.setAttribute('data-viewport', '');\n\n      // remove from nodes\n      this.nodes.delete(id);\n    }\n  }\n\n  addConnector(connector: HTMLLogicFlowConnectorElement) {\n    const id = nanoid();\n    connector.id = id;\n    this.connectors.set(id, connector);\n    const connectorEl = connector.querySelector('.connector');\n    const rect = connectorEl.getBoundingClientRect();\n    this.connectorRects[id] = {\n      left: rect.x - this.viewportOffset.left,\n      top: rect.y - this.viewportOffset.top,\n      width: rect.width,\n      height: rect.height,\n    };\n\n    return id;\n  }\n\n  removeConnector(id: string) {\n    const connector = this.connectors.get(id);\n\n    // remove connections\n    connector.connections.forEach(\n      (connection: HTMLLogicFlowConnectionElement) => {\n        const id = connection.id;\n        if (id) this.removeConnection(id);\n      },\n    );\n\n    this.connectors.delete(id);\n    this.connectorQuadtree.remove(id);\n    delete this.connectorRects[id];\n  }\n\n  addConnection(connection: HTMLLogicFlowConnectionElement) {\n    const id = nanoid();\n    connection.id = id;\n    this.connections.set(id, connection);\n    // set data attribute for the context id\n    connection.setAttribute('data-viewport', this.uid);\n\n    return id;\n  }\n\n  removeConnection(id: string) {\n    const connection = this.connections.get(id);\n    if (!connection) return;\n    // connection.setAttribute('data-viewport', '');\n    // remove from dom\n    // const el = document.getElementById(id);\n\n    // if (el) {\n    //   el.remove();\n    // }\n\n    // TODO: find connectors and remove connections\n    // handle connectors\n    const connectors = connection.connectors;\n    if (connectors.size > 0) {\n      // for (let i = 0; i < connectors.size; i++) {\n      //   const connector = connectors.\n      //   const connIndex = connector.connections.indexOf(connection);\n      //   if (connIndex > -1) {\n      //     connector.connections.splice(connIndex, 1);\n      //   }\n      //   connector.connectingConnector = null;\n\n      //   // update quadtree\n      // }\n      for (const connector of connectors) {\n        const connIndex = connector.connections.indexOf(connection);\n        if (connIndex > -1) {\n          connector.connections.splice(connIndex, 1);\n        }\n        connector.connectingConnector = null;\n        // update quadtree\n      }\n    }\n\n    delete this.connectionRects[id];\n    this.viewportQuadtree.remove(id);\n    this.connections.delete(id);\n    connection.remove();\n  }\n\n  // mutation observer callback\n  // when elements are added or removed from the dom\n  // we need to register or unregister them if they are nodes, connectors or connections\n  viewportMutation(mutations: MutationRecord[]) {\n    if (!mutations.length) return;\n    // happens whenu using bringNodeToFront\n    // - stop the observer from firing\n    // if (!this.registerNode) return;\n    if (this.bringingToFront) {\n      this.bringingToFront = false;\n      return;\n    }\n\n    mutations.forEach(mutation => {\n      if (mutation.type === 'childList') {\n        for (let i = 0; i < mutation.addedNodes.length; i++) {\n          const node = mutation.addedNodes[i];\n          if (node instanceof HTMLElement) {\n            if (node.tagName === 'LOGIC-FLOW-NODE') {\n              const logicNode = node as HTMLLogicFlowNodeElement;\n              this.addNode(logicNode);\n            } else if (node.tagName === 'LOGIC-FLOW-CONNECTOR') {\n              const logicConnector = node as HTMLLogicFlowConnectorElement;\n              this.addConnector(logicConnector);\n            } else if (node.tagName === 'LOGIC-FLOW-CONNECTION') {\n              const logicConnection = node as HTMLLogicFlowConnectionElement;\n              this.addConnection(logicConnection);\n            }\n          }\n        }\n\n        for (let i = 0; i < mutation.removedNodes.length; i++) {\n          const node = mutation.removedNodes[i];\n          if (node instanceof HTMLElement) {\n            if (node.tagName === 'LOGIC-FLOW-NODE') {\n              const logicNode = node as HTMLLogicFlowNodeElement;\n              this.removeNode(logicNode.getAttribute('id'));\n            } else if (node.tagName === 'LOGIC-FLOW-CONNECTOR') {\n              const logicConnector = node as HTMLLogicFlowConnectorElement;\n              this.removeConnector(logicConnector.getAttribute('id'));\n            } else if (node.tagName === 'LOGIC-FLOW-CONNECTION') {\n              const logicConnection = node as HTMLLogicFlowConnectionElement;\n              this.removeConnection(logicConnection.getAttribute('id'));\n            }\n          }\n        }\n      }\n    });\n  }\n\n  static initializeViewport(viewport: HTMLLogicFlowViewportElement) {\n    // need to register all nodes, connectors and connections\n    // that are already in the dom\n\n    const id = viewport.id;\n    const instance = ViewContext.instances.get(id);\n\n    const contentEl = viewport.querySelector('.viewport-content');\n    const children = contentEl.children;\n\n    const traverse = (el: HTMLElement) => {\n      if (el.tagName === 'LOGIC-FLOW-NODE') {\n        const logicNode = el as HTMLLogicFlowNodeElement;\n        instance.addNode(logicNode);\n      } else if (el.tagName === 'LOGIC-FLOW-CONNECTOR') {\n        const logicConnector = el as HTMLLogicFlowConnectorElement;\n        instance.addConnector(logicConnector);\n      } else if (el.tagName === 'LOGIC-FLOW-CONNECTION') {\n        const logicConnection = el as HTMLLogicFlowConnectionElement;\n        instance.addConnection(logicConnection);\n      }\n\n      const children = el.children;\n      for (let i = 0; i < children.length; i++) {\n        traverse(children[i] as HTMLElement);\n      }\n    };\n\n    for (let i = 0; i < children.length; i++) {\n      traverse(children[i] as HTMLElement);\n    }\n  }\n\n  bringToFront(node: HTMLElement) {\n    this.bringingToFront = true;\n    node.parentElement?.appendChild(node);\n  }\n\n  static setCursor(cursor: string) {\n    document.body.style.cursor = cursor;\n  }\n\n  static resetCursor() {\n    document.body.style.cursor = 'default';\n  }\n\n  getRectCenter(rect: DOMRect | Rect) {\n    return {\n      x: rect.left + rect.width / 2,\n      y: rect.top + rect.height / 2,\n    };\n  }\n\n  startPanning(worldCoords: Coords, cursor = 'grabbing') {\n    ViewContext.setCursor(cursor);\n    this.isPanning = true;\n    this.dragStart = worldCoords;\n  }\n\n  panCamera(loc: Coords) {\n    this.camera.pos = {\n      x: loc.x / this.camera.zoom - this.dragStart.x,\n      y: loc.y / this.camera.zoom - this.dragStart.y,\n    };\n\n    this.debouncedUpdateVisibleElements();\n  }\n\n  resetPointerStates() {\n    this.isPanning = false;\n    this.initialPinchDistance = 0;\n    ViewContext.resetCursor();\n  }\n\n  startNodeDrag(\n    target: HTMLLogicFlowNodeElement,\n    worldCoords: Coords,\n    cursor = 'grabbing',\n  ): boolean {\n    if (!target) return false;\n\n    const node = target.closest('logic-flow-node') as HTMLLogicFlowNodeElement;\n    if (!node) return false;\n\n    ViewContext.setCursor(cursor);\n    this.activeNode = node;\n    this.bringToFront(node);\n\n    const pos = this.activeNode.position;\n    this.activeNodeDragging = true;\n    this.activeNodeDragStart = {\n      x: worldCoords.x - pos.x,\n      y: worldCoords.y - pos.y,\n    };\n\n    return true;\n  }\n\n  updateNodeConnectorPos(aNode: HTMLLogicFlowNodeElement, delta: Coords) {\n    const connectors = aNode.querySelectorAll(\n      'logic-flow-connector',\n    ) as NodeListOf<HTMLLogicFlowConnectorElement>;\n\n    for (let i = 0; i < connectors.length; i++) {\n      const connector = connectors[i];\n      const rect = { ...this.connectorRects[connector.id] };\n      rect.left += delta.x;\n      rect.top += delta.y;\n      this.connectorRects[connector.id] = rect;\n\n      this.updateNodeConnectorConnectionsPos(connector, rect);\n    }\n  }\n\n  updateNodeConnectorConnectionsPos(\n    connector: HTMLLogicFlowConnectorElement,\n    rect: Rect,\n  ) {\n    if (connector.connections.length) {\n      const pos = this.getRectCenter(rect);\n\n      for (let i = 0; i < connector.connections.length; i++) {\n        const connection = connector.connections[i];\n        if (connector.type === 'input') {\n          connection.end = pos;\n        } else {\n          connection.start = pos;\n        }\n      }\n    }\n  }\n\n  calcSnapToGrid(pos: Coords, gridSize: number) {\n    return {\n      x: Math.round(pos.x / gridSize) * gridSize,\n      y: Math.round(pos.y / gridSize) * gridSize,\n    };\n  }\n\n  calcNodePos(worldCoords: Coords) {\n    const pos = {\n      x: worldCoords.x - this.activeNodeDragStart.x,\n      y: worldCoords.y - this.activeNodeDragStart.y,\n    };\n\n    if (!this.snapToGrid) return pos;\n\n    return this.calcSnapToGrid(pos, this.connectorSnapDistance);\n  }\n\n  moveNode(loc: Coords, gridSize: number) {\n    const aNode = this.activeNode;\n    const worldCoords = this.camera.toWorldCoords(loc);\n    const oldPos = aNode.position;\n\n    let newPos = this.calcNodePos(worldCoords);\n\n    // calc new position\n    if (this.snapToGrid) {\n      newPos = this.calcSnapToGrid(newPos, gridSize);\n    }\n\n    const delta = {\n      x: newPos.x - oldPos.x,\n      y: newPos.y - oldPos.y,\n    };\n\n    // update node rect\n    const rect = this.nodeRects[aNode.id];\n    rect.left = newPos.x;\n    rect.top = newPos.y;\n    rect.width = aNode.clientWidth || rect.width;\n    rect.height = aNode.clientHeight || rect.height;\n    this.nodeRects[aNode.id] = rect;\n\n    // update node position and it's connections\n    this.updateNodeConnectorPos(aNode, delta); // ???\n\n    aNode.position = newPos;\n  }\n\n  endNodeDrag() {\n    this.activeNodeDragging = false;\n    this.updateNodeConnectorsQuadtree(this.activeNode);\n\n    // update connections rects\n    const connections = this.activeNode.querySelectorAll(\n      'logic-flow-connection',\n    );\n\n    for (let i = 0; i < connections.length; i++) {\n      const connection = connections[i] as HTMLLogicFlowConnectionElement;\n      const path = connection.querySelector('path');\n      const rect = path.getBoundingClientRect();\n      this.connectionRects[connection.id] = {\n        left:\n          (rect.x - this.viewportOffset.left) / this.camera.zoom -\n          this.camera.pos.x,\n        top:\n          (rect.y - this.viewportOffset.top) / this.camera.zoom -\n          this.camera.pos.y,\n        width: rect.width / this.camera.zoom,\n        height: rect.height / this.camera.zoom,\n      };\n      this.updateViewportQuadtree(connection);\n    }\n    this.updateViewportQuadtree(this.activeNode);\n\n    this.activeNode = null;\n  }\n\n  createNewConnection(startPos: Coords, type: 'input' | 'output') {\n    const connection = document.createElement(\n      'logic-flow-connection',\n    ) as HTMLLogicFlowConnectionElement;\n    connection.start = startPos;\n    connection.end = startPos;\n    connection.type = type;\n\n    this.activeConnection = connection;\n    this.contentEl.appendChild(connection);\n  }\n\n  moveActiveConnection(loc: Coords, snappingDist: number) {\n    const aConn = this.activeConnection;\n    // const scrollOffset = {\n    //   x: window.scrollX,\n    //   y: window.screenY,\n    // };\n    // console.log(\n    //   'scrollOffset',\n    //   window.screenY,\n    //   window.scrollY,\n    //   this.viewportEl.offsetTop,\n    // );\n\n    const worldCoords = this.camera.toWorldCoords({\n      x: loc.x - this.viewportOffset.left,\n      y: loc.y - this.viewportOffset.top,\n    });\n\n    const snappableConnector = this.connectorQuadtree.checkNearby(\n      {\n        x: loc.x - this.viewportOffset.left,\n        y: loc.y - this.viewportOffset.top,\n      },\n      snappingDist * this.camera.zoom,\n    );\n\n    if (snappableConnector) {\n      const rect = this.connectorRects[snappableConnector.id];\n      aConn.end = this.getRectCenter(rect);\n    } else {\n      aConn.end = worldCoords;\n    }\n  }\n\n  getTargetConnector(target: HTMLElement, loc: Coords, snappingDist: number) {\n    let targetConnector = target.closest(\n      'logic-flow-connector .connector',\n    ) as HTMLLogicFlowConnectorElement;\n\n    // const scrollOffset = {\n    //   x: window.scrollX,\n    //   y: window.scrollY,\n    // };\n\n    const snappedConnector = this.connectorQuadtree.checkNearby(\n      {\n        x: loc.x - this.viewportOffset.left,\n        y: loc.y - this.viewportOffset.top,\n      },\n      snappingDist * this.camera.zoom,\n    );\n\n    if (snappedConnector) {\n      targetConnector = this.connectors.get(snappedConnector.id);\n    }\n\n    return targetConnector;\n  }\n\n  startNewConnection(\n    target: HTMLLogicFlowConnectorElement,\n    cursor = 'grabbing',\n  ) {\n    if (!target) return false;\n\n    const connEl = target.closest(\n      'logic-flow-connector .connector',\n    ) as HTMLLogicFlowConnectorElement;\n    if (!connEl) return false;\n\n    ViewContext.setCursor(cursor);\n    this.activeConnector = connEl;\n\n    const parentConn = connEl.closest(\n      'logic-flow-connector',\n    ) as HTMLLogicFlowConnectorElement;\n    const rect = this.connectorRects[parentConn.id];\n    const center = this.getRectCenter(rect);\n\n    this.createNewConnection(center, parentConn.type);\n\n    return true;\n  }\n\n  processConnection(target: HTMLLogicFlowConnectorElement) {\n    const aConn = this.activeConnector.closest(\n      'logic-flow-connector',\n    ) as HTMLLogicFlowConnectorElement;\n    const tConn = target.closest(\n      'logic-flow-connector',\n    ) as HTMLLogicFlowConnectorElement;\n\n    // find parent nodes\n    const aNode = aConn.closest('logic-flow-node') as HTMLLogicFlowNodeElement;\n    const tNode = tConn.closest('logic-flow-node') as HTMLLogicFlowNodeElement;\n\n    // validate connection\n    if (!this.isValidConnection(aConn, tConn, aNode, tNode, target)) {\n      this.activeConnection.remove();\n      // remove from rects\n      delete this.connectionRects[this.activeConnection.id];\n      return;\n    }\n\n    this.updateConnectionEndpoints(aConn, tConn);\n    this.finalizeConnection(aConn, tConn);\n\n    // update rect\n    const path = this.activeConnection.querySelector('path');\n    const rect = path.getBoundingClientRect();\n    this.connectionRects[this.activeConnection.id] = {\n      left:\n        (rect.x - this.viewportOffset.left) / this.camera.zoom -\n        this.camera.pos.x,\n      top:\n        (rect.y - this.viewportOffset.top) / this.camera.zoom -\n        this.camera.pos.y,\n      width: rect.width / this.camera.zoom,\n      height: rect.height / this.camera.zoom,\n    };\n\n    // use debug div to show connection\n    // const debug = document.getElementById('debug');\n    // const debugRect = this.connectionRects[this.activeConnection.id];\n    // if (debug) {\n    //   debug.style.left = `${debugRect.left}px`;\n    //   debug.style.top = `${debugRect.top}px`;\n    //   debug.style.width = `${debugRect.width}px`;\n    //   debug.style.height = `${debugRect.height}px`;\n    // }\n\n    // update quadtree\n    this.updateViewportQuadtree(this.activeConnection);\n  }\n\n  isValidConnection(\n    aConn: HTMLLogicFlowConnectorElement,\n    tConn: HTMLLogicFlowConnectorElement,\n    aNode: HTMLLogicFlowNodeElement,\n    tNode: HTMLLogicFlowNodeElement,\n    targetConn: HTMLLogicFlowConnectorElement,\n  ) {\n    // avoid connecting to self or already connected\n    if (\n      this.activeConnector.connectingConnector === tConn ||\n      tConn.connectingConnector === aConn\n    ) {\n      // perhaps send an error event\n      // console.log('already connected');\n      return false;\n    }\n\n    if (aNode === tNode || this.activeConnector === targetConn) {\n      // connecting to self\n      return false;\n    }\n\n    // ensure is between input/output not same type\n    if (aConn.type === tConn.type) {\n      // console.log('same type');\n      return false;\n    }\n\n    return true;\n  }\n\n  updateConnectionEndpoints(\n    active: HTMLLogicFlowConnectorElement,\n    target: HTMLLogicFlowConnectorElement,\n  ) {\n    const targRect = this.connectorRects[target.id];\n\n    if (active.type === 'input') {\n      // swap start and end connections\n      this.activeConnection.start = this.getRectCenter(targRect);\n      this.activeConnection.end = this.activeConnectorStartPos;\n      this.activeConnection.type = 'output';\n\n      const rect = this.connectorRects[active.id];\n      this.activeConnection.end = this.getRectCenter(rect);\n    } else {\n      this.activeConnection.end = this.getRectCenter(targRect);\n    }\n  }\n\n  finalizeConnection(\n    active: HTMLLogicFlowConnectorElement,\n    target: HTMLLogicFlowConnectorElement,\n  ) {\n    active.connectingConnector = target;\n    active.connections.push(this.activeConnection);\n    target.connectingConnector = active;\n    target.connections.push(this.activeConnection);\n\n    this.activeConnection.connectors.clear();\n    this.activeConnection.connectors.add(active);\n    this.activeConnection.connectors.add(target);\n  }\n\n  startDisconnectConnection(\n    target: HTMLLogicFlowConnectionElement,\n    loc: Coords,\n    snappingDist: number,\n    cursor = 'grabbing',\n  ) {\n    if (!target) return false;\n\n    const connection = target.closest(\n      'logic-flow-connection',\n    ) as HTMLLogicFlowConnectionElement;\n    if (!connection) return false;\n\n    this.bringToFront(connection);\n\n    // const scrollOffset = {\n    //   x: window.scrollX,\n    //   y: window.scrollY,\n    // };\n\n    const snappableConnector = this.connectorQuadtree.checkNearby(\n      {\n        x: loc.x - this.viewportOffset.left,\n        y: loc.y - this.viewportOffset.top,\n      },\n      snappingDist * this.camera.zoom,\n    );\n\n    if (!snappableConnector) return false;\n\n    ViewContext.setCursor(cursor);\n    this.activeConnection = connection;\n\n    const snapConnector = this.connectors.get(snappableConnector.id);\n    this.activeConnector =\n      snapConnector.connectingConnector as HTMLLogicFlowConnectorElement;\n\n    this.disconnectConnector(\n      this.activeConnection,\n      this.activeConnector,\n      snapConnector,\n    );\n\n    // handle type specific logic\n    if (this.activeConnector.type === 'input') {\n      this.swapConnectionEndpoints(this.activeConnection);\n      this.activeConnection.type = 'input';\n    }\n\n    return true;\n  }\n\n  disconnectConnector(\n    connection: HTMLLogicFlowConnectionElement,\n    connector: HTMLLogicFlowConnectorElement,\n    snapConnector: HTMLLogicFlowConnectorElement,\n  ) {\n    connector.connections = connector.connections.filter(c => c !== connection);\n    snapConnector.connections = snapConnector.connections.filter(\n      c => c !== connection,\n    );\n\n    connector.connectingConnector = null;\n    snapConnector.connectingConnector = null;\n  }\n\n  swapConnectionEndpoints(connection: HTMLLogicFlowConnectionElement) {\n    const { start, end } = connection;\n    connection.start = end;\n    connection.end = start;\n  }\n\n  updateNodeConnectorsQuadtree(node: HTMLLogicFlowNodeElement) {\n    const connectors = node.querySelectorAll(\n      'logic-flow-connector',\n    ) as NodeListOf<HTMLLogicFlowConnectorElement>;\n    for (let i = 0; i < connectors.length; i++) {\n      const connector = connectors[i];\n      let rect = this.connectorRects[connector.id];\n      if (!rect) {\n        let connectorEl = connector.querySelector('.connector');\n\n        const r = connectorEl.getBoundingClientRect();\n        this.connectorRects[connector.id] = {\n          left: r.x,\n          top: r.y,\n          width: r.width,\n          height: r.height,\n        };\n        rect = this.connectorRects[connector.id];\n      }\n\n      this.connectorQuadtree.remove(connector.id);\n      this.connectorQuadtree.insert({\n        id: connector.id,\n        x: rect.left + rect.width / 2,\n        y: rect.top + rect.height / 2,\n      });\n    }\n  }\n\n  updateViewportQuadtree(\n    entity: HTMLLogicFlowNodeElement | HTMLLogicFlowConnectionElement,\n  ) {\n    if (entity.tagName === 'LOGIC-FLOW-NODE') {\n      const rect = this.nodeRects[entity.id];\n\n      this.viewportQuadtree.remove(entity.id);\n\n      this.viewportQuadtree.insert({\n        id: entity.id,\n        top: rect.top,\n        left: rect.left,\n        width: rect.width,\n        height: rect.height,\n      });\n    } else if (entity.tagName === 'LOGIC-FLOW-CONNECTION') {\n      const rect = this.connectionRects[entity.id];\n\n      this.viewportQuadtree.remove(entity.id);\n\n      this.viewportQuadtree.insert({\n        id: entity.id,\n        top: rect.top,\n        left: rect.left,\n        width: rect.width,\n        height: rect.height,\n      });\n    }\n  }\n\n  updateVisibleElements() {\n    // Get visible nodes within the viewport quadtree\n    let rect = this.viewportRect;\n    rect = {\n      left: rect.left,\n      top: rect.top,\n      width: rect.width,\n      height: rect.height,\n    };\n\n    const visibleEntities = this.viewportQuadtree.query(\n      rect,\n      [],\n      this.camera.pos,\n      this.camera.zoom,\n    );\n\n    const newVisibleElements = visibleEntities.map((entity: any) => entity.id);\n    console.log('newVisibleElements', newVisibleElements);\n\n    const allItems = new Set([\n      ...this.prevVisibleElements,\n      ...newVisibleElements,\n    ]);\n\n    // Update the previous visible elements\n    this.prevVisibleElements = newVisibleElements;\n\n    // Update elements that changed visibility\n    for (const id of allItems) {\n      const el = document.getElementById(id);\n      if (el) {\n        const entityComponent = el as\n          | HTMLLogicFlowNodeElement\n          | HTMLLogicFlowConnectionElement;\n        const curstate = entityComponent.isVisible;\n        const prevState = this.prevVisibleElements.includes(id);\n        const newstate = newVisibleElements.includes(id);\n        if (prevState === curstate && newstate === curstate) {\n          continue;\n        }\n\n        entityComponent.isVisible = newVisibleElements.includes(id);\n      }\n    }\n  }\n}\n","import { Camera } from '../types/Camera';\n\nexport const renderCanvasGrid = (\n  canvas: HTMLCanvasElement,\n  width: number,\n  height: number,\n  gridSize: number,\n  color: string,\n  bgColor: string,\n  camera: Camera,\n) => {\n  const ctx = canvas.getContext('2d');\n  if (!ctx) {\n    return;\n  }\n\n  let step = gridSize * camera.zoom;\n\n  // if the step is too small because of zoom, increase it by a factor of 10\n  if (step < 10) {\n    step *= 2;\n  }\n\n  // const dpr = window.devicePixelRatio || 1;\n  // canvas.width = width * dpr;\n  // canvas.height = height * dpr;\n  // ctx.scale(dpr, dpr);\n\n  // canvas.width = width;\n  // canvas.height = height;\n\n  ctx.strokeStyle = color;\n  ctx.lineWidth = 1;\n\n  //clear\n  ctx.fillStyle = bgColor;\n  ctx.fillRect(0, 0, width, height);\n\n  const offsetX = (-camera.pos.x % gridSize) * camera.zoom;\n  const offsetY = (-camera.pos.y % gridSize) * camera.zoom;\n\n  ctx.beginPath();\n\n  for (let x = -offsetX; x < width; x += step) {\n    ctx.moveTo(x, 0);\n    ctx.lineTo(x, height);\n  }\n\n  for (let y = -offsetY; y < height; y += step) {\n    ctx.moveTo(0, y);\n    ctx.lineTo(width, y);\n  }\n\n  ctx.stroke();\n};\n\nexport const renderCanvasDotGrid = (\n  canvas: HTMLCanvasElement,\n  width: number,\n  height: number,\n  gridSize: number,\n  color: string,\n  bgColor: string,\n  camera: Camera,\n) => {\n  const ctx = canvas.getContext('2d');\n  if (!ctx) {\n    return;\n  }\n\n  let step = gridSize * camera.zoom;\n\n  // if the step is too small because of zoom, increase it by a factor of 10\n  if (step < 10) {\n    step *= 2;\n  }\n\n  // const dpr = window.devicePixelRatio || 1;\n  // canvas.width = width * dpr;\n  // canvas.height = height * dpr;\n  // ctx.scale(dpr, dpr);\n\n  ctx.strokeStyle = color;\n  ctx.lineWidth = 1;\n\n  //clear\n  ctx.fillStyle = bgColor;\n  ctx.fillRect(0, 0, width, height);\n\n  const offsetX = (-camera.pos.x % gridSize) * camera.zoom;\n  const offsetY = (-camera.pos.y % gridSize) * camera.zoom;\n\n  ctx.beginPath();\n\n  // for (let x = -offsetX; x < width; x += step) {\n  //   for (let y = -offsetY; y < height; y += step) {\n  //     ctx.moveTo(x, y);\n  //     ctx.arc(x, y, 1, 0, 2 * Math.PI);\n  //   }\n  // }\n\n  ctx.fillStyle = color;\n\n  for (let x = -offsetX; x < width; x += step) {\n    for (let y = -offsetY; y < height; y += step) {\n      //  ctx.moveTo(x, y);\n      //  ctx.arc(x, y, 1, 0, 2 * Math.PI);\n      // use fill rect\n      ctx.fillRect(x - 1, y - 1, 2, 2);\n    }\n  }\n\n  ctx.stroke();\n};\n",":host {\n  display: block;\n}\n","import { Component, Prop, h, Element, Watch, Method } from '@stencil/core';\nimport { debounce } from '../../utils/debounce';\nimport { throttle } from '../../utils/throttle';\nimport { getEventLocation } from '../../utils/getEventLocation';\nimport { ViewContext } from '../../types/ViewContext';\nimport {\n  renderCanvasDotGrid,\n  renderCanvasGrid,\n} from '../../utils/renderCanvasGrid';\nimport { Coords } from '../../types/Coords';\n\n@Component({\n  tag: 'logic-flow-viewport',\n  styleUrl: 'logic-flow-viewport.css',\n  shadow: false,\n})\nexport class LogicFlowViewport {\n  @Element() el: HTMLLogicFlowViewportElement;\n\n  // @Prop() showGrid: boolean = true;\n  // @Prop() showDotGrid: boolean = false;\n  @Prop() showGrid: boolean = true;\n  @Prop() gridType: 'line' | 'dot' = 'line';\n  @Prop() gridSize: number = 20;\n  @Prop() gridBgColor: string = '#f7f7f7';\n  @Prop() gridLineColor: string = '#555555';\n  @Prop() maxZoom: number = 3;\n  @Prop() minZoom: number = 0.2;\n  @Prop() zoomSpeed: number = 0.08;\n  @Prop() snapToGrid: boolean = false;\n  @Prop() connectorSnappingDistance: number = 37;\n  @Prop() cursors: Record<string, string> = {\n    default: 'auto',\n    panning: 'grabbing',\n    moving: 'grabbing',\n  };\n\n  ctx: ViewContext;\n\n  resizeObserver: ResizeObserver;\n  debouncedResize = debounce(() => this.onResize(), 16);\n  debouncedUpdateScreen = debounce(() => this.updateScreen(), 1);\n  debouncedUpdateViewportRect = debounce(\n    () => this.ctx.updateViewportRect(),\n    100,\n  );\n  throttledTouchMove = throttle(e => this.handleTouchMove(e), 1);\n  forceContentReflowDebounced = debounce(() => this.forceContentReflow(), 30);\n\n  elMouseDown = (e: MouseEvent | TouchEvent) => this.onPointerDown(e);\n  elMouseUp = (e: MouseEvent | TouchEvent) => this.onPointerUp(e);\n  elMouseMove = (e: MouseEvent | TouchEvent) => this.onPointerMove(e);\n\n  elTouchStart = (e: TouchEvent) => this.handleTouchStart(e);\n  elTouchMove = (e: TouchEvent) => this.throttledTouchMove(e);\n  elTouchEnd = (e: MouseEvent | TouchEvent) => this.onPointerUp(e);\n\n  elWheel = (e: WheelEvent) => this.handleWheel(e);\n\n  elScroll = () => this.debouncedUpdateViewportRect();\n\n  elKeyPress = (e: KeyboardEvent) => this.onKeyPress(e);\n\n  componentDidLoad() {\n    this.ctx = new ViewContext(this.el);\n    // this.ctx.camera = this.ctx.camera;\n\n    this.ctx.viewportEl = this.el.querySelector(\n      '.logic-flow-viewport',\n    ) as HTMLDivElement;\n    this.ctx.contentEl = this.el.querySelector(\n      '.viewport-content',\n    ) as HTMLDivElement;\n    this.ctx.gridEl = this.el.querySelector(\n      '.logic-flow-grid',\n    ) as HTMLCanvasElement;\n    // this.ctx.viewportRect = this.ctx.viewportEl.getBoundingClientRect();\n    this.ctx.initialPinchDistance = 0;\n    this.ctx.snapToGrid = this.snapToGrid;\n    this.ctx.connectorSnapDistance = this.connectorSnappingDistance;\n\n    const viewportEl = this.ctx.viewportEl;\n\n    // setup event listeners\n    window.addEventListener('mousedown', this.elMouseDown, {\n      passive: true,\n    });\n    viewportEl.addEventListener('mouseup', this.elMouseUp, { passive: true });\n    viewportEl.addEventListener('mousemove', this.elMouseMove, {\n      passive: true,\n    });\n\n    viewportEl.addEventListener('touchstart', this.elTouchStart, {\n      passive: false,\n    });\n    viewportEl.addEventListener('touchmove', this.elTouchMove, {\n      passive: false,\n    });\n    viewportEl.addEventListener('touchend', this.elTouchEnd, { passive: true });\n\n    viewportEl.addEventListener('wheel', this.elWheel, { passive: false });\n\n    window.addEventListener('scroll', this.elScroll, { passive: true });\n\n    window.addEventListener('keydown', this.elKeyPress, { passive: true });\n\n    // Handle resize events\n    this.resizeObserver = new ResizeObserver(() => this.debouncedResize());\n    this.resizeObserver.observe(this.ctx.viewportEl);\n\n    this.renderGrid();\n  }\n\n  disconnectedCallback() {\n    // Clean up resize observer\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n    }\n\n    // Clean up event listeners\n    const canvasEl = this.ctx.viewportEl;\n    window.removeEventListener('mousedown', this.elMouseDown);\n    canvasEl.removeEventListener('mouseup', this.elMouseUp);\n    canvasEl.removeEventListener('mousemove', this.elMouseMove);\n\n    canvasEl.removeEventListener('touchstart', this.elTouchStart);\n    canvasEl.removeEventListener('touchmove', this.elTouchMove);\n    canvasEl.removeEventListener('touchend', this.elTouchEnd);\n\n    canvasEl.removeEventListener('wheel', this.elWheel);\n\n    window.removeEventListener('scroll', this.elScroll);\n\n    window.removeEventListener('keydown', this.elKeyPress);\n\n    this.ctx.destroy();\n  }\n\n  @Method()\n  async getCamera() {\n    return this.ctx.camera;\n  }\n\n  @Method()\n  async screenToWorldCoords(screenCoords: Coords) {\n    // adjust screen coords to viewport offset\n    const loc = {\n      x: screenCoords.x - this.ctx.viewportOffset.left,\n      y: screenCoords.y - this.ctx.viewportOffset.top,\n    };\n\n    return this.ctx.camera.toWorldCoords(loc);\n  }\n\n  @Watch('snapToGrid')\n  onSnapToGridChange() {\n    this.ctx.snapToGrid = this.snapToGrid;\n  }\n\n  @Watch('gridType')\n  onGridTypeChange() {\n    this.ctx.needsRedraw = true;\n    this.renderGrid();\n  }\n\n  scheduleComponentUpdate() {\n    this.ctx.needsRedraw = true;\n    this.ctx.debouncedUpdateVisibleElements();\n    this.debouncedUpdateScreen();\n  }\n\n  onResize() {\n    // console.log('onResize');\n    this.ctx.needsRedraw = true;\n    this.ctx.viewportRect = this.ctx.viewportEl.getBoundingClientRect();\n\n    this.ctx.gridEl.width = this.ctx.viewportRect.width;\n    this.ctx.gridEl.height = this.ctx.viewportRect.height;\n\n    this.ctx.viewportOffset = {\n      top: this.ctx.viewportRect.top,\n      left: this.ctx.viewportRect.left,\n    };\n\n    // update quadtree boundary\n    const boundary = {\n      left: this.ctx.viewportRect.left - this.ctx.viewportRect.left,\n      top: this.ctx.viewportRect.top - this.ctx.viewportRect.top,\n      width: this.ctx.viewportRect.width,\n      height: this.ctx.viewportRect.height,\n    };\n\n    // get set viewport rect\n    this.ctx.viewportRect = boundary;\n\n    this.ctx.connectorQuadtree.boundary = this.ctx.viewportRect;\n    this.ctx.viewportQuadtree.boundary = this.ctx.viewportRect;\n\n    this.renderGrid();\n  }\n\n  renderGrid() {\n    if (!this.showGrid || !this.ctx.needsRedraw) return;\n\n    requestAnimationFrame(() => {\n      if (this.gridType === 'line') {\n        renderCanvasGrid(\n          this.ctx.gridEl,\n          this.ctx.viewportRect.width,\n          this.ctx.viewportRect.height,\n          this.gridSize,\n          this.gridLineColor,\n          this.gridBgColor,\n          this.ctx.camera,\n        );\n      }\n\n      if (this.gridType === 'dot') {\n        renderCanvasDotGrid(\n          this.ctx.gridEl,\n          this.ctx.viewportRect.width,\n          this.ctx.viewportRect.height,\n          this.gridSize,\n          this.gridLineColor,\n          this.gridBgColor,\n          this.ctx.camera,\n        );\n      }\n    });\n\n    this.ctx.needsRedraw = false;\n  }\n\n  updateScreen() {\n    requestAnimationFrame(() => {\n      const contentEl = this.ctx.contentEl;\n      // Apply transformations to the content, aligning with the grid\n      contentEl.style.transform = `perspective(1px) scale(${this.ctx.camera.zoom}) translate(${this.ctx.camera.pos.x}px, ${this.ctx.camera.pos.y}px)`;\n      this.renderGrid();\n    });\n  }\n\n  onKeyPress(event: KeyboardEvent) {\n    // if delete key pressed\n    // check if node or connection is current focused\n    // if so, delete it\n\n    if (event.key === 'Delete') {\n      const target = document.activeElement as HTMLElement;\n\n      if (target.tagName === 'LOGIC-FLOW-NODE') {\n        // this.ctx.removeNode(target.id);\n        // remove from dom\n        target.remove();\n      } else if (target.closest('logic-flow-connection')) {\n        // this.ctx.removeConnection(target.id);\n        // remove from dom\n        // target.remove();\n        const connection = target.closest('logic-flow-connection');\n        connection.remove();\n      }\n    }\n  }\n\n  onPointerDown(event: MouseEvent | TouchEvent) {\n    const loc = getEventLocation(event);\n    const worldCoords = this.ctx.camera.toWorldCoords(loc);\n    const target = document.elementFromPoint(loc.x, loc.y) as HTMLElement;\n\n    // if pointer outside viewport, return\n    if (\n      loc.x > this.ctx.viewportOffset.left + this.ctx.viewportRect.width ||\n      loc.x < this.ctx.viewportOffset.left ||\n      loc.y > this.ctx.viewportOffset.top + this.ctx.viewportRect.height ||\n      loc.y < this.ctx.viewportOffset.top\n    ) {\n      return;\n    }\n\n    // if target is not a logic-flow element, return\n    if (\n      !target ||\n      !target.closest(\n        'logic-flow-node, logic-flow-connector, logic-flow-connection, logic-flow-viewport',\n      )\n    ) {\n      return;\n    }\n\n    // if a connection clicked\n    if (\n      this.ctx.startDisconnectConnection(\n        target as HTMLLogicFlowConnectionElement,\n        loc,\n        this.connectorSnappingDistance,\n        this.cursors.moving,\n      )\n    )\n      return;\n\n    // if a connector clicked\n    if (this.ctx.startNewConnection(target as HTMLLogicFlowConnectorElement))\n      return;\n\n    // if a node clicked\n    if (this.ctx.startNodeDrag(target as HTMLLogicFlowNodeElement, worldCoords))\n      return;\n\n    // if nothing clicked, then start panning\n    this.ctx.startPanning(worldCoords);\n  }\n\n  onPointerUp(event: MouseEvent | TouchEvent) {\n    if (this.ctx.activeConnector && this.ctx.activeConnection) {\n      this.onEndActiveConnection(event);\n    } else if (this.ctx.activeNode && this.ctx.activeNodeDragging) {\n      this.ctx.endNodeDrag();\n    }\n\n    this.ctx.resetPointerStates();\n  }\n\n  onEndActiveConnection(event: MouseEvent | TouchEvent) {\n    const loc = getEventLocation(event);\n    let target = event.target as HTMLElement;\n\n    // For touch events, get the element at the touch point\n    if (event instanceof TouchEvent) {\n      target = document.elementFromPoint(loc.x, loc.y) as HTMLElement;\n    }\n\n    let targetConnector = this.ctx.getTargetConnector(\n      target,\n      loc,\n      this.connectorSnappingDistance,\n    );\n\n    if (targetConnector) {\n      this.ctx.processConnection(targetConnector);\n    } else {\n      this.ctx.activeConnection.remove();\n    }\n\n    // clear active states\n    this.ctx.activeConnector = null;\n    this.ctx.activeConnection = null;\n  }\n\n  onPointerMove(event: MouseEvent | TouchEvent) {\n    const loc = getEventLocation(event);\n\n    if (this.ctx.activeConnector && this.ctx.activeConnection) {\n      this.ctx.moveActiveConnection(loc, this.connectorSnappingDistance);\n    } else if (this.ctx.activeNode && this.ctx.activeNodeDragging) {\n      this.ctx.moveNode(loc, this.gridSize);\n    } else if (this.ctx.isPanning) {\n      this.ctx.panCamera(loc);\n      this.scheduleComponentUpdate();\n    }\n  }\n\n  handleWheel(event: WheelEvent) {\n    event.preventDefault();\n\n    const canvasRect = this.ctx.viewportRect;\n    const mouseX =\n      event.clientX - canvasRect.left - this.ctx.viewportOffset.left;\n    const mouseY = event.clientY - canvasRect.top - this.ctx.viewportOffset.top;\n\n    // Calculate the zoom level change\n    const zoomDelta = event.deltaY < 0 ? this.zoomSpeed : -this.zoomSpeed;\n    const newZoom = Math.min(\n      this.maxZoom,\n      Math.max(this.minZoom, this.ctx.camera.zoom + zoomDelta),\n    );\n\n    // Calculate the scale factor\n    const scaleFactor = newZoom / this.ctx.camera.zoom;\n\n    // Adjust the pan position to keep the same point under the cursor\n    const newPanX =\n      mouseX -\n      (mouseX - this.ctx.camera.pos.x * this.ctx.camera.zoom) * scaleFactor;\n\n    const newPanY =\n      mouseY -\n      (mouseY - this.ctx.camera.pos.y * this.ctx.camera.zoom) * scaleFactor;\n\n    // Update pan and zoom\n    this.ctx.camera.pos = { x: newPanX / newZoom, y: newPanY / newZoom };\n\n    // this.lastZoom = this.ctx.camera.zoom;\n    this.ctx.camera.zoom = newZoom;\n\n    // if zooming in, force a reflow to prevent blurry text\n    if (zoomDelta > 0) {\n      this.forceContentReflowDebounced();\n    }\n\n    // this.ctx.needsRedraw = true;\n    this.scheduleComponentUpdate();\n  }\n\n  handleTouchStart(event: TouchEvent) {\n    if (event.touches.length === 1) {\n      // Single touch -> start panning\n      this.onPointerDown(event);\n    } else if (event.touches.length === 2) {\n      // Multi-touch -> start pinch zoom\n      this.ctx.initialPinchDistance = 0; // Reset initial pinch distance\n      this.handlePinch(event); // Start pinch gesture\n    }\n  }\n\n  handleTouchMove(event: TouchEvent) {\n    if (event.touches.length === 1) {\n      // Single touch -> panning\n      this.onPointerMove(event);\n    } else if (event.touches.length === 2) {\n      // Multi-touch -> pinch zooming\n      this.handlePinch(event);\n    }\n  }\n\n  handlePinch(event: TouchEvent) {\n    if (event.touches.length !== 2) return;\n\n    // handle panning while pinching\n    this.onPointerMove(event);\n\n    event.preventDefault(); // Prevent default behavior like scrolling\n\n    const touch1 = event.touches[0];\n    const touch2 = event.touches[1];\n\n    // Calculate the distance between the two touch points (pinch)\n    const distance = Math.sqrt(\n      (touch1.clientX - touch2.clientX) ** 2 +\n        (touch1.clientY - touch2.clientY) ** 2,\n    );\n\n    if (this.ctx.initialPinchDistance === 0) {\n      // If it's the start of the pinch, initialize the pinch distance\n      this.ctx.initialPinchDistance = distance;\n    } else {\n      // Calculate the scale factor based on the distance change\n      const scaleFactor = distance / this.ctx.initialPinchDistance;\n\n      // Calculate the midpoint between the two fingers (the pinch center)\n      const pinchCenterX = (touch1.clientX + touch2.clientX) / 2;\n      const pinchCenterY = (touch1.clientY + touch2.clientY) / 2;\n\n      // Apply zoom and keep the pinch center fixed\n      this.adjustZoomOnPinch(scaleFactor, pinchCenterX, pinchCenterY);\n\n      // Update the initial pinch distance for the next move\n      this.ctx.initialPinchDistance = distance;\n    }\n  }\n\n  adjustZoomOnPinch(\n    scaleFactor: number,\n    pinchCenterX: number,\n    pinchCenterY: number,\n  ) {\n    // Calculate new zoom, ensuring it stays within min/max bounds\n    const newZoom = Math.min(\n      this.maxZoom,\n      Math.max(this.minZoom, this.ctx.camera.zoom * scaleFactor),\n    );\n\n    // Find the pinch center position relative to the content's current position and zoom\n    const pinchContentX =\n      (pinchCenterX - this.ctx.camera.pos.x * this.ctx.camera.zoom) /\n      this.ctx.camera.zoom;\n    const pinchContentY =\n      (pinchCenterY - this.ctx.camera.pos.y * this.ctx.camera.zoom) /\n      this.ctx.camera.zoom;\n\n    // Adjust pan so the pinch center stays fixed after zooming\n    this.ctx.camera.pos = {\n      x: pinchCenterX / newZoom - pinchContentX,\n      y: pinchCenterY / newZoom - pinchContentY,\n    };\n\n    // Apply the new zoom level\n    this.ctx.camera.zoom = newZoom;\n\n    // Trigger a screen redraw\n    this.debouncedUpdateScreen();\n  }\n\n  forceContentReflow() {\n    // force repaint the content\n    const cdisplay = this.ctx.contentEl.style.display;\n    this.ctx.contentEl.style.display = 'none';\n    this.ctx.contentEl.offsetHeight; // trigger reflow\n    this.ctx.contentEl.style.display = cdisplay;\n  }\n\n  render() {\n    return (\n      // <Host>\n      <div class=\"logic-flow-viewport\">\n        <canvas\n          class=\"logic-flow-grid\"\n          style={{ display: this.showGrid ? 'block' : 'none' }}\n        ></canvas>\n        <div class=\"viewport-content\">\n          <slot></slot>\n        </div>\n      </div>\n      // /* </Host> */\n    );\n  }\n}\n"],"mappings":"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","ignoreList":[]}